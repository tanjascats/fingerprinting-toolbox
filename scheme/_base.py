from abc import ABC, abstractmethod
from hashlib import blake2b
from bitstring import BitArray


class Scheme(ABC):
    """
    Abstract scheme for all schemes implemented within the toolbox
    """

    # todo: default values
    def __init__(self, fingerprint_bit_length=32, secret_key=333, number_of_buyers=10):
        self.fingerprint_bit_length = fingerprint_bit_length
        self.secret_key = secret_key
        self.number_of_buyers = number_of_buyers

    @abstractmethod
    def insertion(self, dataset_name, buyer_id):
        pass

    @abstractmethod
    def detection(self, dataset_name, real_buyer_id):
        pass

    def create_fingerprint(self, buyer_id):
        """
        :param buyer_id:
        :return: fingerprint (BitArray)
        """
        if buyer_id < 0 or buyer_id >= self.number_of_buyers:
            print("Please specify valid buyer id")
            exit()

        # seed is generated by concatenating secret key with buyers id
        shift = 10
        # seed is 42 bit long
        seed = (self.secret_key << shift) + buyer_id
        b = blake2b(key=seed.to_bytes(6, 'little'), digest_size=int(self.fingerprint_bit_length / 8))
        fingerprint = BitArray(hex=b.hexdigest())
        fp_msg = "\nGenerated fingerprint for buyer " + str(buyer_id) + ": " + fingerprint.bin + "Inserting the " \
                                                                                                 "fingerprint...\n"
        print(fp_msg)
        return fingerprint

    def detect_potential_traitor(self, fingerprint):
        shift = 10
        # for each buyer
        for buyer_id in range(self.number_of_buyers):
            buyer_seed = (self.secret_key << shift) + buyer_id
            b = blake2b(key=buyer_seed.to_bytes(6, 'little'), digest_size=int(self.fingerprint_bit_length / 8))
            buyer_fp = BitArray(hex=b.hexdigest())
            buyer_fp = buyer_fp.bin
            if buyer_fp == fingerprint:
                return buyer_id
        return -1
